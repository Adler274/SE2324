# DevOps

**Autor:** Simon Fedrau


## Lernziele

hier kommen die Lernziele hin



## DevOps

Unter DevOps versteht man diverse Praktiken, Tools und eine Kulturphilosophie, die die Prozesse zwischen Softwareentwicklungs- und IT-Teams automatisieren und integrieren. Im Vordergrund stehen dabei Teambefähigung, teamübergreifende Kommunikation und Zusammenarbeit sowie Technologieautomatisierung.

Die DevOps-Bewegung begann um das Jahr 2007, als die Communitys für Softwareentwicklung und IT Operations Bedenken über das traditionelle Softwareentwicklungsmodell äußerten, bei dem die Entwickler, die den Code schrieben, getrennt von Operations-Teams arbeiteten, die den Code bereitstellten und unterstützten. Der Begriff DevOps, eine Kombination aus den Wörtern Development und Operations, spiegelt den Prozess der Integration beider Fachgebiete in einen kontinuierlichen Prozess wider.
[1a] [2a]

![:scale 50%](media\Titelbild-devops-tools-definition-best-practice.png)


### Kultur, Ziele, Vorteile

**Kultur** 

Auf organisatorischer Ebene erfordert DevOps eine kontinuierliche Kommunikation, Zusammenarbeit und gemeinsame Verantwortung aller an der Softwarebereitstellung Beteiligten, d. h. der Softwareentwicklungs- und IT-Betriebsteams, aber auch der Sicherheits-, Compliance-, Governance-, Risiko- und Geschäftsleitungsteams, um schnelle und kontinuierliche Innovationen zu erzielen und die Qualität der Software von Anfang an zu gewährleisten.

In den meisten Fällen lässt sich dies am besten erreichen, indem man diese Silos aufbricht und sie in funktionsübergreifende, autonome DevOps-Teams umorganisiert, die von Anfang bis Ende – von der Planung bis zum Feedback – an Code-Projekten arbeiten können, ohne Übergaben an andere Teams vorzunehmen oder auf deren Genehmigungen warten zu müssen. Im Kontext der agilen Entwicklung sind die gemeinsame Verantwortlichkeit und die Zusammenarbeit die Grundlage für einen gemeinsamen Produktfokus, der zu einem wertvollen Ergebnis führt.

Auf technischer Ebene erfordert DevOps ein Engagement für die Automatisierung, die Projekte innerhalb und zwischen Workflows in Bewegung hält. Außerdem sind Feedback und Messungen erforderlich, die es den Teams ermöglichen, die Zyklen kontinuierlich zu beschleunigen und die Softwarequalität und -leistung zu verbessern.

[3a] [4a]
**Ziele**

Das ultimative Ziel einer DevOps-Pipeline ist die Schaffung eines wiederholbaren Systems, das die Automatisierung nutzt und kontinuierliche Verbesserungen ermöglicht, um qualitativ hochwertige Produkte schneller und einfacher zu liefern.
[6a]

**Vorteile**

Zusammenarbeit und Vertrauen, intelligenteres und transparenteres Arbeiten, schnellere Releases, kürzere Problemlösungszeiten und ein besseres Management unvorhersehbarer Aufgaben sind die elementaren Vorteile von DevOps.

Teams, die die DevOps-Methode anwenden, können durch Automatisierung und standardisierte Tools ihre Produktivität steigern und problemloser zu häufigeren Releases gelangen. Durch eine vollständige Transparenz verkürzt sich der Feedbackkreislauf und Probleme sowie Aufgaben können schneller gelöst und erledigt werden. Mit etablierten Prozessen und einer klaren Priorisierung, die sich durch die agile Methode flexibel an den Projektverlauf anpassen lässt, können die Teams ungeplante Aufgaben besser managen und ihre geplanten Aufgaben nicht aus den Augen verlieren.
[5a]

### DevOps Teams

DevOps-Teams bestehen normalerweise aus Personen, die sowohl im Entwicklungs- als auch Operations-Bereich über Kenntnisse verfügen. Einige Teammitglieder können besser Code schreiben, während sich andere vielleicht besser mit dem Betrieb und der Verwaltung der Infrastruktur auskennen. In großen Unternehmen kann jedoch jeder Aspekt von DevOps, der von CI/CD über IaaS bis hin zur Automatisierung reicht, mit einer Rolle besetzt werden. Dazu können Release-Manager gehören, die Anwendungen von der Entwicklung bis zur Produktion koordinieren und verwalten, oder Automatisierungsarchitekten, die die CI/CD-Pipeline eines Teams warten und automatisieren.

Was braucht man, um einem DevOps-Team beitreten zu können? Die Jobanforderungen für den Beitritt zu einem DevOps-Team entwickeln sich aufgrund neuer Technologien und Techniken weiter, gute DevOps-Teams zeichnen sich aber immer durch dieselben Eigenschaften aus. Solide technische Fähigkeiten, gute Kommunikation, Teamplayer-Mentalität und Anpassungsfähigkeit sind einige der wichtigsten Merkmale von fähigen DevOps-Fachleuten. Wahrscheinlich ist es wichtiger, mehrere dieser Eigenschaften vorweisen zu können, als ein enzyklopädisches Wissen über Kubernetes oder Git. Es schadet aber nicht, beides zu haben.
[7a]

#### Struktur, Rollen, Verantwortlichkeiten


**Struktur** muss noch überarbeitet werden!!!!!
***
Welche DevOps-Teamstruktur implementiert werden soll, hängt von zahlreichen Faktoren ab. Das sind beispielsweise die Anzahl der Produkte, an denen ein Unternehmen arbeitet, die technische Führung und die Fähigkeit von Entwicklungs- und Operations-Teams, Prozesse aufeinander abzustimmen.
Es ist wichtig zu verstehen, dass nicht jedes Team dieselben Ziele verfolgt oder dieselben Praktiken und Tools verwendet. Selbst die Art und Weise, wie ein Team zusammengesetzt ist, sollte nicht standardisiert werden. Je nach den Umständen des Unternehmens und seinem Drang, sich zu verändern, benötigen verschiedene Teams unterschiedliche Strukturen. DevOps-Teams in zwei unterschiedlichen Unternehmen können sich massiv voneinander unterscheiden.


Kultur und Zusammenarbeit: DevOps beginnt oft mit einer kulturellen Veränderung, bei der die Zusammenarbeit zwischen Entwicklung und Betrieb gefördert wird. Dies erfordert einen Kulturwandel, bei dem Teams enger zusammenarbeiten, um gemeinsame Ziele zu erreichen.

Automatisierung: Automatisierung ist ein zentrales Element von DevOps. Sie umfasst die Automatisierung von Build-, Test-, Bereitstellungs- und Konfigurationsprozessen, um menschliche Fehler zu minimieren und die Bereitstellungszeit zu verkürzen.

Kontinuierliche Integration (CI): Dies beinhaltet die regelmäßige Integration von Codeänderungen in ein gemeinsames Repository, gefolgt von automatisierten Builds und Tests. Dadurch werden Konflikte frühzeitig erkannt und die Codequalität verbessert.

Kontinuierliche Bereitstellung (CD): CD geht über CI hinaus und beinhaltet die automatisierte Bereitstellung von Anwendungen in Produktionsumgebungen. Dies ermöglicht es, Software schnell und zuverlässig zu liefern.

Überwachung und Feedback: Die kontinuierliche Überwachung von Anwendungen in Produktionsumgebungen ist wichtig, um Probleme schnell zu erkennen und zu beheben. Feedbackschleifen helfen bei der ständigen Verbesserung von Prozessen und Anwendungen.

Mikroservices-Architektur: Viele DevOps-Umgebungen nutzen Mikroservices, um Anwendungen in kleinere, unabhängig bereitstellbare Teile aufzuteilen. Dies erleichtert die Skalierbarkeit und Aktualisierung von Teilen der Anwendung.

Infrastruktur als Code (IaC): IaC ermöglicht die Verwaltung von Infrastrukturkomponenten (z. B. Server, Netzwerke) mit dem gleichen Code, der auch die Anwendungen definiert. Dies sorgt für Konsistenz und Wiederholbarkeit.

Sicherheit (DevSecOps): Sicherheit ist ein wichtiger Aspekt von DevOps. DevSecOps integriert Sicherheit in den gesamten DevOps-Lebenszyklus, um sicherzustellen, dass Sicherheitslücken frühzeitig erkannt und behoben werden.

Tooling: DevOps verwendet eine Vielzahl von Tools für Automatisierung, CI/CD, Überwachung und mehr. Beispiele sind Jenkins, Docker, Kubernetes, Ansible, und viele andere.

Agile-Prinzipien: DevOps baut oft auf den Prinzipien der Agilen Softwareentwicklung auf, um flexible und iterative Entwicklungsprozesse zu unterstützen.


**Rollen**
***

**DevOps-Ingenieur**
Ein DevOps-Ingenieur ist sowohl in der Entwicklung als auch im Betrieb versiert und hat ein Händchen für den Einsatz neuer Technologien. Diese Rolle identifiziert Projektanforderungen und optimiert die vom Team verwendeten Tools. DevOps-Ingenieure sind für die Bereitstellung der Umgebung, die Einrichtung von Pipelines und die Automatisierung verantwortlich. Darüber hinaus helfen sie dabei, die richtige Teamzusammensetzung aufzustellen, Prozesse zu definieren und alle erforderlichen Funktionen während des gesamten Release-Lifecycle zu integrieren.

**Release-Manager**
In der DevOps-Teamstruktur verwaltet die Person in dieser Rolle den gesamten Release-Lifecycle, von der Entwicklung bis zur Auslieferung. Sie stellen sicher, dass jede Phase des Prozesses reibungslos verläuft und überwachen Feedback und Key Metrics.

**Automatisierungsarchitekt**
Die Verantwortung eines Automatisierungsarchitekten besteht darin, die vorhandenen Prozesse zu analysieren und Möglichkeiten zur Verkürzung der Vorlaufzeit, Erhöhung der Bereitstellungshäufigkeit und Minimierung der Mean Time To Recovery (MTTR) zu identifizieren. Sie führen Best Practices ein, um Prozesse zu rationalisieren und zu automatisieren und die Anzahl manueller Aufgaben zu reduzieren. Ziel ist es die Effizienz des Lieferprozesses zu steigern. In vielen Fällen kann diese Verantwortung jedoch vom gesamten Team geteilt werden oder auf den DevOps-Ingenieur fallen.


**Softwareentwickler/Tester**
Genau wie bei anderen DevOps-Rollen ist ein Entwickler/Tester während des gesamten Produktlebenszyklus beteiligt. Sie schreiben Code für neue Produkte und Funktionen, führen Tests und Deployments durch und überwachen die Produktleistung.

**Sicherheits- und Compliance-Ingenieur**
Diese Rolle überwacht die Sicherheit der DevOps-Umgebung. Der Security-Spezialist arbeitet eng mit dem Entwicklungsteam zusammen, um Sicherheitsmaßnahmen in die CI/CD-Pipeline zu integrieren und die Daten- und Produktsicherheit sowie die Einhaltung aller erforderlichen Vorschriften zu gewährleisten. Die Rolle kann auch Teil der Verantwortung eines technischen Architekten sein.

**UX-Ingenieur**
Diese Rolle steht im Zusammenhang mit der Qualitätssicherung, legt aber auch großen Wert auf die Benutzererfahrung. Die UX-Profis überprüfen, ob die Produktfeatures den etablierten Standards entsprechen und stellen außerdem sicher, dass sie einfach zu bedienen sind und ein hervorragendes Kundenerlebnis bieten.
[8a]


### DevOps Pipelines und Automation
***

DevOps-Pipelines und Automation sind zentrale Konzepte in der DevOps-Methodik, die darauf abzielen, Softwareentwicklung und -bereitstellung zu automatisieren und zu optimieren. Eine DevOps-Pipeline ist eine Reihe von Automatisierungsprozessen, die den gesamten Lebenszyklus der Softwareentwicklung und -bereitstellung abdecken
[9a]

#### Continuous Integration, Delivery und Deployment

Continuous Integration, Continuous Delivery und Continuous Deployment sind Methoden, mit denen der Software-Releaseprozess beschleunigt werden soll, indem Feedback-Schleifen verkürzt und wiederholungsintensive Aufgaben automatisiert werden. Diese Methoden spielen eine Schlüsselrolle dabei, das Agile-Prinzip – Bereitstellung von wertvoller, funktionierender Software in kurzen Abständen – in die Wirklichkeit umzusetzen
[10a]

**Continuous Integration**

Angenommen, mehrere Personen arbeiten an einem Softwareprodukt, was die Regel für die meisten kommerziellen und Open-Source-Projekte sein dürfte: Irgendwann müssen die separaten Teile, an denen die einzelnen Mitwirkenden gearbeitet haben, kombiniert werden, um zu überprüfen, ob das Endprodukt wie beabsichtigt funktioniert. Bei Continuous Integration passiert dies mindestens einmal am Tag oder noch häufiger.

Die Begründung ist einfach. Wenn wir die Integration hinausschieben, bis der gesamte Code fertig ist, ist die Wahrscheinlichkeit hoch, dass wir einige Zeit damit verbringen müssen, Teile des Codes zu entfernen und neu zu schreiben, um überhaupt den Build zum Laufen zu bekommen – vom Erreichen der angepeilten Funktionalität gar nicht zu reden. Software ist komplex. Selbst wenn vorab ein detailliertes Design erstellt wird, ist es unglaublich schwierig, Probleme zu vermeiden und genau vorherzusagen, wie die Logik interagieren wird. Je größer der Umfang des Codes ist, desto größer ist die Komplexität und desto mehr muss rückgebaut werden, wenn etwas nicht funktioniert.

Durch Continuous Integration steuern die einzelnen Mitwirkenden ihre Änderungen regelmäßig zum Gesamtsystem bei, indem sie mindestens einmal am Tag einen Commit in die Quellcodeverwaltung durchführen und dabei überprüfen, ob der Build durchläuft und die Tests besteht. Dadurch müssen bei einem Fehler weitaus weniger Änderungen analysiert werden, um die Ursache zu finden. Außerdem sind bei zeitnahem Feedback Probleme leichter zu beheben, da den Entwickler*innen der Kontext ihrer Aktivitäten noch präsent ist.

[10a]

**Continuous Delivery**

Bei Continuous Delivery ersetzen wir die manuellen Schritte, mit denen wir ein Build unserer Software für die Produktion freigeben, durch einen automatisierten Prozess.

Früher erfolgte oft eine Übergabe von der Entwicklung an die Testabteilung und von dort an das Release-Management. Durch Continuous Delivery ist das gesamte Team (mit Mitgliedern aus verschiedenen Disziplinen) für den kompletten Prozess verantwortlich: Build, Test und Release. Dies bringt mehrere Vorteile mit sich:

Durch die Vermeidung der traditionellen Silos hat das Entwicklungsteam einen besseren Einblick in die geschäftlichen und operativen Anforderungen, die zur Bereitstellung des Produkts an die Benutzer*innen erfüllt werden müssen.
Dies eröffnet wiederum die Möglichkeit, Methoden aus der Softwareentwicklung in einen normalerweise manuellen und oft recht langwierigen Prozess einzubringen.
Durch Automatisierung der Schritte zur Bereitstellung eines Produkts wird nicht nur der Prozess beschleunigt, sondern auch das Fehlerrisiko verringert, und das Produkt wird stabiler und zuverlässiger.
Die genauen Schritte für die Bereitstellung von Software – und somit die erforderlichen Phasen in der Delivery-Pipeline – variieren je nach Geschäfts- und Nutzungsanforderungen. Normalerweise jedoch durchläuft eine Software vor dem Release mindestens eine Vorproduktionsumgebung.

Diese Vorproduktionsumgebungen können unterschiedlich gestaltet sein, zum Beispiel als Testumgebungen mit zusätzlichen Testebenen für Sicherheits-, Last- oder Leistungstests, als Sandbox-Umgebungen, in denen sich Support- und Vertriebsteams mit neuen Funktionen vertraut machen, oder als Akzeptanztestumgebungen, in denen QS- und Produktexperten überprüfen, ob die Änderungen nach Plan funktionieren.
Bei Continuous Delivery wird jeder erfolgreiche Build automatisch in jeder Vorproduktionsumgebung bereitgestellt, wobei das Vertrauen in die Qualität mit jeder Phase zunimmt.
[10a]

**Continuous Deployment**

Wenn ein Build alle vorangehenden Phasen der Pipeline erfolgreich durchläuft, wird er automatisch in die Produktion übernommen. Dies bedeutet, dass jede Änderung sofort den Weg zu Ihrer Benutzergemeinde findet, sobald die Software alle Tests bestanden hat. Durch Continuous Deployment wird die Feedback-Schleife zwischen Codeänderung und Produktionseinsatz verkürzt, sodass Ihr Team einen frühzeitigen Einblick in das Verhalten der Änderungen in der realen Welt erhält, ohne Kompromisse bei der Qualität eingehen zu müssen.

Auch wenn die automatisierte Bereitstellung von Software für die Produktion nicht für jedes Produkt und jede Organisation geeignet ist, lohnt es sich, die dazu erforderlichen Schritte zu betrachten, da jedes einzelne Element bereits für sich genommen wertvoll ist:
[10a]

##### Releasing vs Deployment

Das Deployment zielt darauf ab, die entwickelte Software auf dem Zielsystem zu installieren und lauffähig zu machen.
Eine Software-Version ist ein Entwicklungsstand zu einem bestimmten Zeitpunkt. Ein Release ist ein Deployment auf dem Produktivsystem einer bestimmten Version.


**Deployment**
Das Deployment, auch Verteilung oder Bereitstellung der Software genannt, ist ein Schritt der Softwareentwicklung, der darauf abzielt, die entwickelte Software auf dem Zielsystem zu installieren und lauffähig zu machen.

Die Bereitstellung bedeutet nicht, dass das Projekt damit bereits abgeschlossen ist. Denn zum einen kann ein Deployment auch regelmäßig erfolgen und zum anderen kann Software nicht nur auf das Produktivsystem, sondern auch auf dem Entwicklungs- oder Testsystem verteilt werden, auf dem Entwickler ihre Änderungen ausprobieren oder mit dem Kunden testen könne

Deployment:

Zweck: Deployment bezieht sich auf den Prozess des Verteilens und Aktivierens einer neuen Version einer Anwendung oder eines Dienstes in einer bestimmten Umgebung. Es handelt sich um die technische Aktion, bei der der Code oder die Anwendung auf einer bestimmten Hardware oder Softwareumgebung installiert und in Betrieb genommen wird.
Ort: Deployment erfolgt normalerweise in spezifischen Umgebungen, wie beispielsweise Entwicklung, Test oder Produktion. Es kann auch intern in der Entwicklungs- oder Testumgebung stattfinden, bevor es in die Produktion übergeht.
Beteiligte: Das Deployment kann von DevOps-Teams oder Systemadministratoren durchgeführt werden, um sicherzustellen, dass die Software auf den Zielsystemen ordnungsgemäß installiert und konfiguriert ist.


[11a] [12a]

**Releasing**

Release:

Zweck: Ein Release bezieht sich auf die Freigabe einer bestimmten Version einer Anwendung oder eines Softwareprodukts für den allgemeinen Gebrauch oder für bestimmte Zielgruppen. Ein Release ist eine geschäftliche Entscheidung, bei der eine Version als stabil und bereit für die Verwendung angesehen wird.
Ort: Ein Release kann in verschiedenen Umgebungen bereitgestellt werden, einschließlich Produktion. Es bezieht sich jedoch auf die Freigabe der Software im Allgemeinen und kann auch Aktualisierungen, Bugfixes oder neue Funktionen enthalten.
Beteiligte: Die Freigabeentscheidung wird normalerweise von den Geschäftseinheiten getroffen, wobei verschiedene Stakeholder wie Produktmanager, Qualitätsprüfer und technische Teams involviert sind. Das Release-Management spielt eine Schlüsselrolle bei der Planung und Koordinierung von Releases.
[11a] [12a]


In Zusammenfassung bezieht sich Deployment auf die technische Aktion des Verteilens und Aktivierens von Code oder Anwendungen in bestimmten Umgebungen, während Release die geschäftliche Entscheidung darstellt, eine bestimmte Version der Software für die Verwendung freizugeben. Die Unterscheidung zwischen diesen beiden Konzepten ist wichtig, da sie die Planung, Koordination und Kommunikation zwischen den verschiedenen Teams und Stakeholdern in DevOps-Umgebungen beeinflusst.


##### Semantic Versioning

Auf Grundlage einer Versionsnummer von MAJOR.MINOR.PATCH werden die einzelnen Elemente folgendermaßen erhöht:

MAJOR wird erhöht, wenn API-inkompatible Änderungen veröffentlicht werden.
MINOR wird erhöht, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden, und
PATCH wird erhöht, wenn die Änderungen ausschließlich API-kompatible Bugfixes umfassen.

Semantic Versioning ist besonders nützlich, um Entwicklern und Benutzern von Softwarepaketen schnell und einfach zu zeigen, welche Art von Änderungen in einer bestimmten Version erwartet werden können. Dies erleichtert die Entscheidung, ob ein Update durchgeführt werden sollte, und minimiert das Risiko von Inkompatibilitäten
[13a]

##### Deployment strategies

Eine Deplyment strategy ist eine Technik, die von DevOps-Teams eingesetzt wird, um eine neue Version der von ihnen bereitgestellten Softwarelösung erfolgreich einzuführen. Diese Techniken umfassen die Art und Weise, wie der Netzwerkverkehr in einer Produktionsumgebung von der alten Version auf die neue Version umgestellt wird. Je nach Spezialgebiet des Unternehmens kann eine Bereitstellungsstrategie die Ausfallzeiten und die Betriebskosten des Unternehmens beeinflussen.
[14a]
###### Blue-Green

Bei dieser Art von Deployment strategy läuft die neue Version der Software neben der alten Version. Beachten Sie, dass man dies in manchen Fällen auch als rot/schwarze Bereitstellungsstrategie bezeichnen kann.

Hier ist die stabile oder ältere Version der Anwendung immer blau oder rot, während die neuere Version grün oder schwarz ist.

Nachdem die neue Version getestet und zertifiziert wurde, dass sie alle Anforderungen erfüllt, schaltet der Load Balancer den Datenverkehr automatisch von der älteren Version auf die neuere Version um.


Hauptvorteile:
Keine Ausfallzeiten. Mit einer Blau/Grün-Bereitstellung ist eine schnelle Umstellung ohne Ausfallzeiten möglich.
Sofortiges Rollback. Während des Bereitstellungsprozesses können Sie jederzeit ein Rollback ausführen. Dazu passen Sie den Load-Balancer so an, dass der Traffic zurück zur blauen Umgebung geleitet wird. Die Auswirkungen der Ausfallzeiten beschränken sich auf die Dauer, die nötig ist, um den Traffic in die blaue Umgebung zu verschieben, nachdem Sie ein Problem erkannt haben.
Trennung der Umgebungen. Durch die Blau/Grün-Bereitstellung ist sichergestellt, dass das Starten einer parallelen grünen Umgebung keine Auswirkungen auf Ressourcen hat, die die blaue Umgebung unterstützen. Diese Trennung verringert das Bereitstellungsrisiko.

Hinweise:
Kosten und operativer Aufwand. Die Anwendung des Blau/Grün-Bereitstellungsmusters kann zu einem höheren operativen Aufwand und höheren Kosten führen, da Sie doppelte Umgebungen mit identischer Infrastruktur pflegen müssen.
Abwärtskompatibilität. Blaue und grüne Bereitstellungen können sich Datenpunkte und Datenspeicher teilen. Wir empfehlen Ihnen, zu prüfen, ob beide Versionen der Anwendung das Schema des Datenspeichers und das Format der Datensätze verwenden können. Diese Abwärtskompatibilität ist erforderlich, wenn Sie bei einem Rollback nahtlos zwischen den beiden Versionen wechseln möchten.
Umstellung. Wenn Sie die derzeitige Version außer Betrieb nehmen möchten, empfehlen wir Ihnen, einen angemessenen Verbindungsausgleich für vorhandene Transaktionen und Sitzungen zu ermöglichen. Mit diesem Schritt können von der derzeitigen Bereitstellung verarbeitete Anfragen ordnungsgemäß abgeschlossen oder beendet werden.



[14a] [15a]

###### Canary

Bei der Canary-Bereitstellung richtet das Bereitstellungsteam die neue Version ein und verlagert dann schrittweise den Produktionsverkehr von der älteren Version auf die neuere Version. Zu einem bestimmten Zeitpunkt während des Bereitstellungsprozesses kann die ältere Version beispielsweise 90 % des gesamten Datenverkehrs für die Software übernehmen, während die neuere Version 10 % des Datenverkehrs hostet. Mit dieser Bereitstellungstechnik können die DevOps-Ingenieure die Stabilität der neuen Version testen. Dabei wird der Live-Datenverkehr einer Untergruppe von Endbenutzern auf verschiedenen Ebenen verwendet, die sich im Laufe der Produktion verändern.

Hauptvorteile:
Möglichkeit zum Testen des Live-Produktionstraffics. Anstatt eine Anwendung mithilfe simulierten Traffics in einer Staging-Umgebung zu testen, können Sie Canary-Tests für den Live-Produktionstraffic ausführen. Bei Canary-Rollouts müssen Sie entscheiden, in welchem Umfang Sie die neue Anwendung bei jedem Schritt freigeben und wann Sie den nächsten Schritt in einem Release auslösen. Der Canary-Test benötigt genügend Traffic, damit Probleme über Monitoring zweifelsfrei erkannt werden können.
Schnelles Rollback. Sie können schnell ein Rollback ausführen, indem Sie den Nutzertraffic an die ältere Version der Anwendung weiterleiten.
Keine Ausfallzeiten. Mit Canary-Releases können Sie den Live-Produktionstraffic ohne Ausfallzeit an verschiedene Versionen der Anwendung weiterleiten.

Hinweise:
Langsame Einführung. Für jeden schrittweisen Release ist ein Monitoring über einen angemessenen Zeitraum erforderlich, wodurch sich der Release insgesamt verzögern kann. Canary-Tests können oft mehrere Stunden dauern.
Beobachtbarkeit. Eine Voraussetzung für die Umsetzung von Canary-Tests ist die Möglichkeit, Ihre Infrastruktur und Ihr Anwendungspaket wirksam zu beobachten und zu überwachen. Die Einbindung eines robusten Monitorings kann einen erheblichen Aufwand erfordern.
Abwärtskompatibilität und Sitzungstreue. Wie bei Rolling Updates können auch bei Canary-Tests Risiken für die Abwärtskompatibilität und Sitzungspersistenz auftreten, da während der Bereitstellung der Canary-Version in der Umgebung mehrere Anwendungsversionen ausgeführt werden.


[14a] [15a]


###### Feature flags
Feature Toggles sind eine Technik zur Entkopplung eines Deployments von einem Release und stellen somit eine Alternative zu Feature Branches dar. Diese Technik beschleunigt die Entwicklung, da keine Branches und Merges erforderlich sind. Es können dadurch viele kleine inkrementelle Versionen einer Software bereitgestellt werden, weil es Entwicklern ermöglicht wird, neue oder unvollständige Funktionen zu verstecken, sodass sie nicht in der Benutzeroberfläche erscheinen. Einige nennen das In-Code Branching.

Es gibt Frameworks wie togglz [5], die eine komfortable Benutzeroberfläche bieten, um alle Schalter zu verwalten, zu aktivieren oder zu deaktivieren – vielleicht verbunden mit einer speziellen Releasestrategie. Dabei ist es möglich, eine Funktion beispielsweise nur für wenige Benutzer bereitzustellen, z. B. ausgewählt nach Name, IP-Adresse, Standort, oder schrittweise mit wenigen Prozenten (siehe auch Canary Deployment). Mit diesem Ansatz kann A/B Testing durchgeführt werden, was bedeutet, dass eine Funktion nur für eine Teilmenge der Benutzer zum Ausprobieren aktiviert wird, um zu prüfen, ob die Änderung akzeptiert wird. Wenn ein Feature Fehler verursacht oder einfach nicht so funktioniert, wie es sollte, wird der Schalter deaktiviert und die Entwickler können an einem neuen Inkrement für die Bereitstellung arbeiten. Ein solches Verhalten wird als fix forward bezeichnet und bedeutet, dass es keine Notwendigkeit mehr für Rollbacks gibt. Das kann viel Zeit sparen, denn es kann viel Arbeit bei der Vorbereitung von Datenbankskripten bedeuten, jederzeit zu ermöglichen, auf die letzte Version zurückgehen. Schließlich können Funktionsschalter dafür verwendet werden, eine Anwendung in den Wartungsmodus zu versetzen.

Entwickler müssen den Einstiegspunkt eines Features mit einem if-else-Konstrukt in ihrem Code (Listing 1) umschließen.

Listing 1: Toggles als Weiche im Code

if (Features.ENABLE_IMPORT.isActive()) {
  LOG.info("IMPORT gestartet");
  try {
    Future<Boolean> future = importService.holeDatenVonOnlineAntrag();
  ...
} else {
  LOG.info("IMPORT nicht möglich");
}
    }

Ein Codeblock, der per Schalter ausgeschaltet wurde, ist vergleichbar mit auskommentiertem Code.

Es ist wichtig, darauf zu achten, die Schalter wieder auszubauen, nachdem sie nicht mehr benötigt werden, da ansonsten toter Code entsteht, der zu neuen technischen Schulden führt. Feature Toggles können in einer Datenbank oder als Eigenschaft in einer Konfigurationsdatei gespeichert werden.

[16a]

##### CI/CD-Tools

Ein CI/CD-Tool leistet entscheidende Unterstützung bei dem CI-Management, der Koordination und Automatisierung der verschiedenen Phasen der Pipeline, vom Anstoßen des Prozesses nach einem Commit über die Steuerung des Buildvorgangs bis hin zum Ausführen von automatisierten Tests, dem Veröffentlichen von Artefakten und dem Erfassen und Weiterleiten von Feedback.
Die Wahl des richtigen Continuous-Integration- oder Continuous-Development/Delivery-Tools ist ein wichtiger Schritt bei der Implementierung Ihrer CI/CD-Pipeline.
[17a]

###### CI Server (Jenkins, Github-Actions, etc.)

Der CI-Server (in vielen Fällen ein zentraler Bestandteil des Tools) spielt eine Schlüsselrolle bei der Koordination der kontinuierlichen Integration, indem er sicherstellt, dass Änderungen im Code regelmäßig überwacht, getestet und bereitgestellt werden. Dadurch wird die Qualität der Software verbessert und die Entwicklungsprozesse effizienter gestaltet.

Der CI-Server (oder Build-Server) spielt eine Schlüsselrolle bei der Implementierung und Verwaltung des gesamten Prozesses. Er dient als Bindeglied zwischen den einzelnen Phasen der Pipeline, indem er gemäß Ihrer Geschäftslogik automatisierte Aufgaben koordiniert und Feedback sammelt und bereitstellt.
[19a]
Jenkins: Jenkins ist eines der beliebtesten Open-Source-CI/CD-Tools. Der Jenkins-Server ermöglicht die Automatisierung von Build-, Test- und Bereitstellungsprozessen und bietet eine umfangreiche Auswahl an Plugins und Erweiterungsmöglichkeiten.

Github-Actions:
CI mit GitHub Actions bietet Workflows an, die den Code in deinem Repository erstellen und deine Tests ausführen können. Workflows können auf GitHub-gehosteten VMs ausgeführt werden, oder auf Computern, die du selbst hostest. Weitere Informationen findest du unter Verwenden von auf GitHub gehosteten Runnern und unter Informationen zu selbstgehosteten Runnern.

Du kannnst den CI-Workflow so konfigurieren, dass er bei einem GitHub-Ereignis (z. B. wenn neuer Code per Push in das Repository eingebracht wird), nach einem festen Zeitplan oder bei einem externen Ereignis anhand des Sende-Webhooks des Repositorys ausgeführt wird.

GitHub führt die CI-Tests durch und liefert die Ergebnisse der einzelnen Tests im Pull Request, sodass du feststellen kannst, ob die Änderung im Branch einen Fehler einbringt. Sobald alle CI-Tests in einem Workflow bestanden wurden, können die per Push übermittelten Änderungen von einem Teammitglied geprüft oder zusammengeführt werden. Wenn ein Test nicht bestanden wird, liegt die Ursache eventuell in einer deiner Änderungen.
[18a]



#### Secrets management

Was ist ein Secret?
Diese nicht menschlichen privilegierten Anmeldedaten werden oft als „Secrets“ bezeichnet und sind im Wesentlichen eine private Information, die als Schlüssel zum Freischalten geschützter Ressourcen oder sensibler Daten in Tools, Anwendungen, Containern sowie DevOps- und Cloud-nativen Umgebungen dient.

Zu den häufigsten Arten von Secrets zählen:

Anmeldedaten privilegierter Accounts:
Passwörter
Zertifikate
SSH-Schlüssel
API-Schlüssel
Encryption-Schlüssel

Was ist Secrets-Management?
Secrets-Management gilt als Best Practice in der Cyber-Sicherheitsbranche und ermöglicht Unternehmen die konsequente Durchsetzung von Sicherheitsrichtlinien für nicht menschliche Identitäten. Secrets Management bietet die Gewissheit, dass Ressourcen über sämtliche Tool-Stacks, Plattformen und Cloud-Umgebungen hinweg nur authentifizierten und autorisierten Benutzern zugänglich sind.

Die folgenden Schritte sind in der Regel Teil des Secrets-Managements. Viele dieser Ansätze und Techniken werden auch verwendet, um den privilegierten Zugriff durch menschliche Benutzer zu schützen.

Authentifizierung aller Zugriffsanfragen, bei denen nicht menschliche Anmeldedaten zum Einsatz kommen.
Durchsetzung des Least-Privilege-Prinzips.
Durchsetzung der rollenbasierten Zugriffskontrolle (RBAC) und regelmäßige Rotation von Secrets und Anmeldedaten.
Automatisierung des Secrets-Managements und Anwendung konsistenter Zugriffsrichtlinien.
Verfolgung sämtlicher Zugriffe und Anlegen eines umfassenden Audit-Trails.
Entfernung von Secrets aus Code, Konfigurationsdateien und anderen ungeschützten Bereichen.

[20a]

### Bilder

![](media/image.jpg)

## Referenzen

[1a]  : https://de.wikipedia.org/wiki/DevOps
[2a]  : https://www.atlassian.com/de/devops  
[3a]  : https://www.ibm.com/de-de/topics/devops
[4a]  : https://www.atlassian.com/de/devops/what-is-devops/devops-culture
[5a]  : https://mindsquare.de/knowhow/devops/#vorteile
[6a]  : https://weissenberg-group.de/was-ist-devops/#:~:text=Das%20ultimative%20Ziel%20einer%20DevOps,schneller%20und%20einfacher%20zu%20liefern.
[7a]  : https://www.atlassian.com/de/devops/frameworks/team-structure#:~:text=DevOps%2DTeams%20bestehen%20normalerweise%20aus,der%20Verwaltung%20der%20Infrastruktur%20auskennen.
[8a]  : https://www.objectivity.de/blog/aufbau-einer-effizienten-devops-teamstruktur/
[9a]  : https://www.atlassian.com/de/devops/devops-tools/devops-pipeline#:~:text=Was%20ist%20die%20DevOps%2DPipeline,f%C3%BCr%20eine%20Produktionsumgebung%20arbeiten%20k%C3%B6nnen.
[10a] : https://www.jetbrains.com/de-de/teamcity/ci-cd-guide/continuous-integration-vs-delivery-vs-deployment/
[11a] : https://dakitec.de/software-entwicklung/deployment#:~:text=Das%20Deployment%20zielt%20darauf%20ab,dem%20Produktivsystem%20einer%20bestimmten%20Version.
[12a] : https://chat.openai.com/c/65fcfde4-4f21-4912-bcd4-c5b175833b7c frage: was ist der unterschied zwischen release und deployment im DevOps bereich
[13a] : https://semver.org/
[14a] : https://www.plutora.com/blog/deployment-strategies-6-explained-in-depth
[15a] : https://cloud.google.com/architecture/application-deployment-and-testing-strategies?hl=de
[16a] : https://entwickler.de/devops/roadmap-einer-spannenden-reise
[17a] : https://www.jetbrains.com/de-de/teamcity/ci-cd-guide/ci-cd-tools/#:~:text=Ein%20CI%2FCD%2DTool%20leistet,dem%20Ver%C3%B6ffentlichen%20von%20Artefakten%20und
[18a] : https://docs.github.com/de/actions/automating-builds-and-tests/about-continuous-integration
[19a] : https://www.jetbrains.com/de-de/teamcity/ci-cd-guide/ci-cd-tools/servers/#:~:text=Der%20CI%2DServer%20(oder%20Build,und%20Feedback%20sammelt%20und%20bereitstellt.
[20a] : https://www.cyberark.com/de/what-is/secrets-management/#:~:text=Was%20ist%20Secrets%2DManagement%3F,Sicherheitsrichtlinien%20f%C3%BCr%20nicht%20menschliche%20Identit%C3%A4ten.
